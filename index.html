
<style>
	body {
		padding: 0;
		margin: 0;
	}
</style>
<canvas id=canvas></canvas>
<script>
	var viewport = document.body
	var canvas = document.getElementById('canvas')
	var context = canvas.getContext('2d')
	var canvasHeight = canvas.height = viewport.offsetHeight 
	var canvasWidth = canvas.width = viewport.offsetWidth
	var fontSize = 13
	var fontFamily = 'monospace'
	var byteBlock = fontSize/1.66640
	var lineHeight = fontSize
	var tabSize = 2

	function Buffer (size) {
		this.buff = Array(size)
		this.size = size
		this.lead = 0
		this.tail = 0
    this.line = 0
	}

	Buffer.prototype = {
		forward: forward,
		backward: backward,
		move: move,
		jump: jump,
		insert: insert,
		splice: splice,
		expand: expand,
		render: render
	}

	/**
	 * move foward
   * @return {void} 
	 */
 	function forward () {
 		if (this.tail > 0)
 			this.buff[this.lead++] = this.buff[this.size-this.tail++]
 	}

 	/**
 	 * back
   * @return {void}
 	 */
 	function backward () {
 		if (this.lead > 0)
 			this.buff[this.size-(this.tail++)-1] = this.buff[(this.lead--)-1]
 	}

 	/**
 	 * move
   * @param {number}
   * @return {void}
 	 */
 	function move (distance) {
 		var caret = distance

		while (caret--)
			distance > 0 ? this.forward() : this.backward()
 	}

 	/**
 	 * jump
   * @param {number}
   * @return {void}
 	 */
 	function jump (location) {
 		this.move(location-this.lead)
 	}

  /**
   * insert
   * @param {string} string
   * @return {void}
   */
 	function insert (string) {
 		if (string.length > 0)
 			for (var i = 0; i < string.length; i++)
 				this.splice(string.charAt(i))
 		else
 			this.splice(string)
 	}

  /**
   * split
   * @param {string} char
   * @return {void}
   */
 	function splice (char) {
 		if (this.lead + this.tail === this.size)
 			this.expand()

 		this.buff[this.lead++] = char
 	}

  /**
   * expand
   * @return {void}
   */
 	function expand () {
    this.buff = this.buff.slice(0, this.lead).concat(Array(this.size*=2), this.buff.slice(this.tail))
  }

  /**
   * render
   * @param {number} xAxis
   * @param {number} yAxix
   * @return {void}
   *
   * @todo only render the parts that are in view/delta
   */
 	function render (xAxis, yAxis) {
    var byte = ''
    var buff = this.buff
    var lead = this.lead
    var tail = this.tail
    var len = buff.length
    var size = lead

    var height = lineHeight
    var width = byteBlock
    var tab = tabSize
    var x = xAxis
    var y = yAxis+fontSize

    var i = 0
    var offset = 0
    var code = 0
    var gap = 0

    var cols = canvasWidth
    var rows = canvasHeight

    // setup
    if (cols*rows > 0)
      context.clearRect(0, 0, cols, rows)

    context.font = fontSize+'px '+fontFamily

    // visitor
    while (true) {
      if (i === size) {
        if (tail === 0 || gap++ > 0)
          break
        else
          i = (size = len)-tail
      }

      switch ((byte = buff[i++]).charCodeAt(offset = 0)) {
        // newline
        case 13:
          break
        case 10:
          y += height
          x = 0
          break
        // tab
        case 9:
          offset = tab*width
        default: 
          context.fillText(byte, x, y)
          x += offset+width
      }
    }
 	}

 	var string = 'hello world'
 	var heap = new Buffer(string.length)

 	heap.insert(string)
 	heap.render(0, 0)

  setTimeout(() => {
    heap.backward()
    heap.backward()
    heap.insert('.')
    heap.render(0, 0)
  }, 200)

  /**
   * Draw
   * 
   * @param {Context} ctx
   * @param {Array<Object[]>} data
   * @param {number} xCord
   * @param {number} yCord
   */
  function draw (context, heap, xAxis, yAxis) {
  	
	}

	/**
	 * Clear
	 * 
	 * @param {Context} context
	 */
	function clear (context, x, y, width, height) {
		context.clearRect(x, y, width, height)
	}

  // clear(context, 0, 0, canvasWidth, canvasHeight)
  // draw(context, heap, 0, fontSize)

  // function bench (data, func, name) {
  //   var ops = 10
  //   var index = 0
  //   var start = performance.now()
  //   while (index++ < ops) {
  //     var result = func(data)
  //   }
  //   var end = performance.now()

  //   console.log((end-start)/10+' ops', name, result)
  // }

  // var arr = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

  // function splice (arr) {
  //   return arr.slice(0, 5).concat(new Array(5), arr.slice(5))
  // }

  // function alloc (arr) {
  //   var buff = Array(15)

  //   for (var i = 0; i < 5; i++)
  //     buff[i] = arr[i]

  //   for (var i = 5; i < 11; i++)
  //     buff[i+5] = arr[i]

  //   return buff
  // }

  // bench(arr, alloc, 'alloc')
  // bench(arr, splice, 'alloc')
 </script>
