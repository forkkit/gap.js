
<style>
	body {
		padding: 0;
		margin: 0;
	}
</style>
<canvas id=canvas></canvas>
<script>
	var viewport = document.body
	var canvas = document.getElementById('canvas')
	var context = canvas.getContext('2d')
	var canvasHeight = canvas.height = viewport.offsetHeight 
	var canvasWidth = canvas.width = viewport.offsetWidth
	var fontSize = 13
	var fontFamily = 'monospace'
	var byteBlock = fontSize/1.66640
	var lineHeight = fontSize
	var tabSize = 2

	function Buffer (size) {
    this.size = size
    this.lead = 0
    this.tail = 0

    // entire buffer
    this.buff = Array(size)

    // selected buffer
    this.maps = Array(0)

    // visible buffer
    this.view = [0, 0]
	}

	Buffer.prototype = {
		forward: forward,
		backward: backward,
		move: move,
		jump: jump,
		insert: insert,
		splice: splice,
		expand: expand,
    select: select,
    copy: copy,
    save: save,
    render: render
	}

	/**
	 * move foward
   * @return {void} 
	 */
 	function forward () {
 		if (this.tail > 0)
 			this.buff[this.lead++] = this.buff[this.size-this.tail++]
 	}

 	/**
 	 * back
   * @return {void}
 	 */
 	function backward () {
 		if (this.lead > 0)
 			this.buff[this.size-(this.tail++)-1] = this.buff[(this.lead--)-1]
 	}

 	/**
 	 * move
   * @param {number}
   * @return {void}
 	 */
 	function move (distance) {
 		var caret = distance

		while (caret--)
			distance > 0 ? this.forward() : this.backward()
 	}

 	/**
 	 * jump
   * @param {number}
   * @return {void}
 	 */
 	function jump (location) {
 		this.move(location-this.lead)
 	}

  /**
   * insert
   * @param {string} string
   * @return {void}
   */
 	function insert (string) {
 		if (string.length > 0)
 			for (var i = 0; i < string.length; i++)
 				this.splice(string.charAt(i))
 		else
 			this.splice(string)
 	}

  /**
   * split
   * @param {string} char
   * @return {void}
   */
 	function splice (char) {
 		if (this.lead + this.tail === this.size)
 			this.expand()

 		this.buff[this.lead++] = char
 	}

  /**
   * expand
   * @return {void}
   */
 	function expand () {
    this.buff = this.buff.slice(0, this.lead).concat(Array(this.size*=2), this.buff.slice(this.tail))
  }

  /**
   * select
   */
  function select (x1, y1, x2, y2) {

  }

  /**
   * copy
   * @return {string}
   */
  function copy () {

  }

  /**
   * save
   * @return {string}
   */
  function save () {
    return this.buff.join('')
  }

  /**
   * render
   * @param {number} xAxis
   * @param {number} yAxix
   * @return {void}
   *
   * @todo only render the parts that are in view/delta
   */
 	function render (xAxis, yAxis) {
    var byte = ''
    var buff = this.buff
    var lead = this.lead
    var tail = this.tail
    var len = buff.length
    var size = lead

    var height = lineHeight
    var width = byteBlock
    var tab = tabSize
    var x = xAxis
    var y = yAxis+fontSize

    var i = 0
    var offset = 0
    var code = 0
    var gap = 0

    var cols = canvasWidth
    var rows = canvasHeight

    // setup
    if (cols*rows > 0)
      context.clearRect(0, 0, cols, rows)

    context.font = fontSize+'px '+fontFamily

    // visitor
    while (true) {
      if (i === size) {
        if (tail === 0 || gap++ > 0)
          break
        else
          i = (size = len)-tail
      }

      switch ((byte = buff[i++]).charCodeAt(offset = 0)) {
        // newline
        case 13:
          break
        case 10:
          y += height
          x = 0
          break
        // tab
        case 9:
          offset = tab*width
        default: 
          context.fillText(byte, x, y)
          x += offset+width
      }
    }
 	}

 	var string = 'hello world'
 	var heap = new Buffer(string.length)

 	heap.insert(string)
 	heap.render(0, 0)

  setTimeout(() => {
    heap.backward()
    heap.backward()
    heap.insert('.')
    heap.render(0, 0)
  }, 200)
 </script>
